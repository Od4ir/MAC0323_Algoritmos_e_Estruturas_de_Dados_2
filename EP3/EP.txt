>> Função para gerar letras (x);
>> Função para cortar a string (x);
>> Função que lê strings como id de vértices e adiciona uma aresta
entre esses vértices;
>> Função que verifica se uma aresta u - v está em um circuito;
>> Função que encontra em um grafo acíclico um caminho de comprimen-
to máximo;


// Valores da Tabela ASCII:
// >> A = 65;
// >> C = 67;
// >> G = 71;
// >> T = 84;

------------------------------------------------------------------------

Para gerar as letras, terei que fazer um rand entre 1 e 4, e dependendo
do valor, fazer um append da letra que der; 

------------------------------------------------------------------------

Como eu posso cortar? 
Queremos ter dois parâmetros para o tamanho máximo e mínimo em quantidade
de letras;
E depois, realizar o recorte... Mas como?

Vamos supor que temos 100 letras. Queremos variar o tamanho entre 10 e 20
letras. 

Podemos sortear o tamanho - que será t (com 10 <= t <= 20);
Sorteamos um índice de 0 até 100 - t;
Cortamos a substring;

-----------------------------------------------------------------------

Como fazer um grafo com vértices que tem como id strings?
Preciso de uma estrutura que tenha salvo as chaves ordenadas para faci-
litar sua busca. 

Eu posso ter a estrutura do node da seguinte forma:

typedef struct {
    Key * key;
    int id;
} node;

ABB de nodes - Ordenados pela key;

int N - número de vértices.

node adj[N][M] - Vetor de adjacências;

adj[node.id][i] indica o iésimo node adjacente ao node.id;




Fazer uma class Node com as seguintes propridades;
    - key -- Que identifica o id do vértice (Uma substring);
    - vector<Node> adj -- Vetores de adjagência do vértice;
    - bool vis;

Para uma função que varia pelo Node, para acessar o vetor de
adjagências basta:

for(Node v: atual.adj) {
    if(!v.vis) {
        dfs(v);
    }
}

Como fazer um vetor de visitados?
Ao invés de manter um vetor, mantém um parâmetro em cada Node;
Inicia sempre como false;
(Talvez seja necessário fazer uma função que falsifique-os);

-----------------------------------------------------------------------

Planejamento:

Vamos gerar uma string:
Digite o número de caracteres que deseja na string;
>> string;


Vamos dividir:
Digite o número de substrings que deseja gerar:
<< k;
Digite o tamanho máximo e mínimo dessas strings:
(Lembre-se que para um bom funcionamento MAX != MIN e MAX <= tamanho da
string maior);
>> MIN: 
>> MAX:

Deseja visualizar as strings geradas?
>> S/n

Vamos guardar os vértices gerados em um vetor e ordená-los por ordem alfa-
bética das substrings de cada um;

Pronto!

Vamos adicionar as arestas entre os vértices. 
Deseja visualizar as arestas para cada vértice?
>> S/N;






-----------------------------------------------------------------------

// Funções que podem ser utéis:

string.size() ou string.lenght;
    >> Devolve o tamanho da string, número de caracteres;

string.substr(i, j) 
    >> Retorna uma substring entre os índices i e j;

string.find(palavra)
    >> Retorna se a palavra está na string;

string.compare(string2)
    >> Compara duas strings e:
        devolve 0 se são iguais;
        devolve < 0  se a primeira é menor;
        devolve > 0  se a primeira é maior;

string.append(string2)
    >> Acrescenta uma string ao final da outra;
*/


/*
Para verificar se o final de tamanho k de uma string bate com o
começo de outra string, podemos:

    1) Cortar o final da string1 com a função substring;
    2) Usar o find para verificar se tem um encontro;
        2.1) O find devolve o índice que ocorre esse começo;
            2.1.1) Se o índice for 0, bateu!
            2.1.2) Se o índice não for 0, mas existir achar outro
            índice vale a pena verificar 2 coisas:
                2.1.2.1) Se a string1 inteira cabe dentro dá 
                string2;
                2.1.2.2) Se a string2 inteira cabe dentro da 
                string1;
                2.1.2.3) Se ambas são iguais;
            2.1.3) Se o índice for -1, então não há ligação para
            aquele k testado;
*/


/* 
Vamos ter um grafo em que os vértices são representados por 
strings. E há uma conexão de peso x entre dois vértices se o
começo de um bate com o começo do outro;


(?) 
Professor, no seguinte exemplo, como devo proceder:

Tenho uma string ACC e uma outra CACCT, ACC está dentro da segunda,
e eu consigo verificar isso, eu posso simplesmente excluir a primeira
como se eu estivesse admitindo que ela está dentro da outra?


(?)
O resultado final, tem que ter o mesmo tamanho do inicial? Tipo
eu tenho essa informação?


*/