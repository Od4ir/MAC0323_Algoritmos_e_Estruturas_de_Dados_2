>> Função para gerar letras (x);
>> Função para cortar a string (x);
>> Função que lê strings como id de vértices e adiciona uma aresta
entre esses vértices;
>> Função que verifica se uma aresta u - v está em um circuito;
>> Função que encontra em um grafo acíclico um caminho de comprimen-
to máximo;


// Valores da Tabela ASCII:
// >> A = 65;
// >> C = 67;
// >> G = 71;
// >> T = 84;

------------------------------------------------------------------------

Para gerar as letras, terei que fazer um rand entre 1 e 4, e dependendo
do valor, fazer um append da letra que der; 

------------------------------------------------------------------------

Como eu posso recortar as substrings a partir das cópias?

Vou ter dois parâmetros salvos - MIN e MAX, que vão indicar o intervalo
em que irei cortar a string. 

Então, para cada cópia, eu sorteio um valor entre MIN e MAX e tento divi-
dir a string DNA o número máximo de vezes.

Algumas regras: Não poderão ser geradas strings com menos de k caracteres.
Sendo esse k o parâmetro que vou usar para construir as arestas. 

int tam_total = dna.size();
int tam = rand() % (MAX - MIN) + MIN;

int c = tam_total / tam;
if(c == 0) {
    // Tem que gerar de novo;
}
if(tam_total % tam < k) {
    // Tem que gerar de novo;
}
if(tam_total % tam > k) {
    corta c vezes e o que sobrar vira mais uma. 
}

int copy = 0;
while(copy < n) { 
    int tam_total = dna.size();
    int tam = (rand() % (MAX - MIN)) + MIN;
    int c = tam_total / tam;

    if(tam_total - tam * c < k && c > 1 && tam_total % tam != 0) {
        for(int i = c; i > 0; i--) {
            if(tam_total - tam * c >= k) {
                c = i;
                break;
            }
        }
    }

    if(c != 0 && (tam_total - tam * c >= k || tam_total % tam == 0)) {
        for(int i = c, ind = 0; i > 0; i--) {
            a = dna.substr(ind, tam);
            node no(a, 0);
            v.push_back(no);
            ind = ind + tam;
        }
        int aux = tam_total - tam * c;
        if(aux != 0) {
            node no(dna.substr(ind, aux), 0);
            v.push_back(no);
        }
        copy++;
    }
}


-----------------------------------------------------------------------

Já temos uma estrutura para guardar os nodes, que são os vértices e temos
um id númerico para cada um deles. 

A ideia vai ser achar a primeira aparição de um dado conjunto de caracte-
res e a última aparição. Após isso, teremos os índices, é só iterar por 
eles adicionando arestas. 

-----------------------------------------------------------------------

Planejamento:

Vamos gerar uma string:
Digite o número de caracteres que deseja na string;
>> string;


Vamos dividir:
Digite o número de substrings que deseja gerar:
<< k;
Digite o tamanho máximo e mínimo dessas strings:
(Lembre-se que para um bom funcionamento MAX != MIN e MAX <= tamanho da
string maior);
>> MIN: 
>> MAX:

Deseja visualizar as strings geradas?
>> S/n

Vamos guardar os vértices gerados em um vetor e ordená-los por ordem alfa-
bética das substrings de cada um;

Pronto!

Vamos adicionar as arestas entre os vértices. 
Deseja visualizar as arestas para cada vértice?
>> S/N;

-----------------------------------------------------------------------

Para cada string, tenta começar com o k máximo;
Cria um vetor com os índices das arestas para marcar as que foram visi-
tadas;

    Acha o pri e o ult;

    if(pri <= ult) {
        Preenche entre o pri e o ult;
        Coloca arestas entre o pri e o ult - Para todas que não foram
        visitadas ainda (Isso garante que elas vão ter a intersecção 
        máxima);
    }


Qual vai ser a estrutura?

vector<int> adj[N]



Maneira Complicada:

for(int k = aux.tam; k > k_min; k++) {
    Acha o pri e o ult para o k em questão;

    if(pri >= pri_vis && ult_vis <= ult) {
        Não fazemos nada, pois já foram marcados com um k maior;
    }

    if(ult == pri_vis) { 
        Visitamos e marcamos arestas de peso k para todos os nodes de
        pri a ult - 1;
        pri_vis = pri;
    }    
    else if(ult < pri_vis) { 
        Visitamos e marcamos arestas de peso k para todos os nodes de
        pri a ult;
        pri_vis = pri;
    }
    else if(pri == ult_vis) {
        Visitamos e marcamos arestas de peso k para todos os nodes de
        pri + 1 a ult;
        ult_vis = ult;
    }
    else if(pri > ult)




    if(pri != ult) // Ou seja, se existem nodes para o k em questão;
        Marcamos que esse intervalo já foi inteiro visitado;
        pri_vis = pri, ult_vis = ult;
        Marcamos arestas de peso k para todos esses nodes;
        Voltamos ao loop com um k menor;

}



-----------------------------------------------------------------------

// Funções que podem ser utéis:

string.size() ou string.lenght;
    >> Devolve o tamanho da string, número de caracteres;

string.substr(i, j) 
    >> Retorna uma substring entre os índices i e j;

string.find(palavra)
    >> Retorna se a palavra está na string;

string.compare(string2)
    >> Compara duas strings e:
        devolve 0 se são iguais;
        devolve < 0  se a primeira é menor;
        devolve > 0  se a primeira é maior;

string.append(string2)
    >> Acrescenta uma string ao final da outra;
*/


/*
Para verificar se o final de tamanho k de uma string bate com o
começo de outra string, podemos:

    1) Cortar o final da string1 com a função substring;
    2) Usar o find para verificar se tem um encontro;
        2.1) O find devolve o índice que ocorre esse começo;
            2.1.1) Se o índice for 0, bateu!
            2.1.2) Se o índice não for 0, mas existir achar outro
            índice vale a pena verificar 2 coisas:
                2.1.2.1) Se a string1 inteira cabe dentro dá 
                string2;
                2.1.2.2) Se a string2 inteira cabe dentro da 
                string1;
                2.1.2.3) Se ambas são iguais;
            2.1.3) Se o índice for -1, então não há ligação para
            aquele k testado;
*/


/* 
Vamos ter um grafo em que os vértices são representados por 
strings. E há uma conexão de peso x entre dois vértices se o
começo de um bate com o começo do outro;


(?) 
Professor, no seguinte exemplo, como devo proceder:

Tenho uma string ACC e uma outra CACCT, ACC está dentro da segunda,
e eu consigo verificar isso, eu posso simplesmente excluir a primeira
como se eu estivesse admitindo que ela está dentro da outra?


(?)
O resultado final, tem que ter o mesmo tamanho do inicial? Tipo
eu tenho essa informação?


*/