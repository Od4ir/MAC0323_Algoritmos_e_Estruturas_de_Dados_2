Queremos criar um programa que recebe uma exp. reg que pode
conter:

    >> |        // OK
    >> *        // OK
    >> .        // OK
    >> +        // OK
    >> [ ]      // OK
    >> [ - ]    // OK
    >> [^ ]     // OK

E dado palavras de entrada, informa se a exp. reg. reconhece
a palavra ou não.

Devemos construir o grafo correspondente ao autômato finito
não determinístico da exp. reg. e indentificar se existe um ca-
minho no grafo que represente a palavra.

Entrada:

    Digite a expressão regular:
    - EXPRESSÃO REGULAR -

    [Montagem do grafo]

    Digite o número de palavras que deseja testar:
    - NÚMERO DE PALAVRAS -

    Digite as palavras:
    - LISTA DE PALAVRAS -


Saída:
    Palavra i: (S/N);


Estrutura do Grafo:

    vector<vector<int>> adj;    // Vetor de adjagências;
    string exp_reg;             // String que salva a expressão regular;

    void add_aresta(int u, int v);   // Adiciona uma aresta entre dois vértices; 
    dfs(int u, bool * vis);



Código para criação do grafo:

    for(int i = 0; i < exp_reg.size(); i++) {
        int ant = i;
        stack<int> pilha;

        if(exp_reg[i] == '(' || exp_reg[i] == ')


    }



TESTES:

((A*B)|C)*

((A*B)|(BC)*)


(A*CG|A*TA|AAG*T)*


(.)*A(.)*

R[AEIOU]T[AEIOU]


[]
