Sáida: (Para cada instante)

>> Uma lista com quais aviões estão esperando para pousar ou decolar;
>> O tempo médio de espera de pouso;
>> O tempo médio de espera para decolagem;
>> A quantidade média de combustível dos aviões que estão esperando para pousar;
>> A quantidade média de combustível disponível nos aviões que já pousaram;
>> A quantidade de aviões pousando/decolando em condições de emergência;

>>> Situação de cada pista;


Entrada:

>> T - Unidades de tempo da simulação;
>> K - Número máximo de aviões que chegam no aeroporto por unidade de tempo;
>> pp - Probabilidade de ser um pouso;
>> pd - Probabilidade de ser uma decolagem (1 - pp);
>> pe - Probabilidade de ser de emergência;
>> C - Tempo máximo de combustível de um avião que deseja pousar;
>> V - Tempo máximo de voo de uma decolagem;

LINKS:
    https://www.out4mind.com/listas-ligadas-simples-em-c-parte-i/#:~:text=As%20listas%20ligadas%20s%C3%A3o%20estruturas,duplamente%20ligadas%20e%20listas%20circulares.

Funções: 

AVIÕES:
    void Avioes::cria_aviao(char *id_code, int comb, int dec, int voo, int tipo) {
        for(int i = 0; i < 5; i++) {
            id[i] = id_code[i];
        }
        time_combustivel = comb;
        time_decolagem = dec;
        time_voo = voo;
        type = tipo;
        id_pista = -1;   //Por padrão o avião sempre estará no ar;
    }

    void Avioes::pass_time() {
        time_combustivel--;
    }

    Imprimindo Aviões:
        for(int j = 0; j < quant_avioes; j++) {
            Avioes aux = aux.gera_aviao(C, V, pp, pe);
            printf("Avião %d: ", i + j);
            cout << " >> id: " << aux.id << endl;
            cout << " >> id_voo: " << aux.id_voo << endl;
            cout << " >> comb: " << aux.time_comb << endl;
            cout << " >> voo: " << aux.time_voo << endl;
            cout << " >> type: " << aux.type << endl;
        }
        cout << endl;

PISTAS: 
    void Pista::cria_pista(int id_number) { // Criação da pista;
        id = id_number;
        status = 0;
        timer = 0;
    }

    void Pista::pass_time() { // Passagem de tempo;
        timer = timer - 1;
        if(timer == 0) {
            status = 0;
        }
    }

    void Pista::pouso_ou_decolagem(int tempo, char *id_airplane) { // Utilização da pista;
        timer = tempo;
        status = 1;
        for(int i = 0; i < 5; i++) {
            id_aviao[i] = id_airplane[i];
        }
    }

    void Pista::info_pista() { // Imprimir as informações da pista;
        cout << "ID Pista: " << id << endl;
        cout << "Status: ";
        if(status == 0) cout << "Livre\n";
        else {
            cout << "Interditada/Ocupada\n"; 
            cout << "Durante: " << timer << endl;
        }
    } 

CASOS:

ESTRATÉGIA { 

    Verifica qual o tipo de avião - Especial ou Normal;

    Geração de Aviões {
        Se for Especial {
            Coloca numa subfila especial;
            Ordenada por comb / voo;
        }
        Se for Normal {
            Coloca numa subfila normal;
            Ordenada por comb / voo;
        }
    }

    >>> >>> >>> AVIÃO ESPECIAL {
        coloquei = 0;
        Se for de Decolagem {
            Olha em todas pistas - Ordena elas por quantidade de aviões;
            Deixa a P3 em primeiro lugar;
            While(Não testar todas as pistas && !coloquei) { 
                Se tiver vazia {
                    Coloca em primeiro lugar; ** 
                    Quantidade da Pista++;
                    Tempo de interdição = 3;
                    coloquei = 1;
                }
                Se não tiver {
                    Simula colocar em primeiro; ***
                    Se der certo {
                        Coloca em primeiro lugar;
                        Quantidade da Pista++;
                        coloquei = 1;
                    }
                    Se não der certo {
                        Vai para a próxima pista;
                    }
                }
            }
            Se (!coloquei) {
                Manda para outro aeroporto;
            }
        }
        Se for Pouso {
            Olha na Pista 1 e 2 (Ordena por quantidade de aviões) 
            Deixa a 3 como última a testar;
            While(Não testar todas as pistas && !coloquei) {
                Se tiver vazia {
                    Coloca em primeiro lugar;
                    Quantidade da Pista++;
                    Tempo de interdição = 3;
                    coloquei = 1;
                }
                Se não tiver {
                    Simula colocar em primeiro; ***
                    Se der certo {
                        Coloca em primeiro lugar; ***
                        Quantidade da Pista++;
                        Tempo de interdição++
                        coloquei = 1;
                    }
                    Se não der certo {
                        Vai para a próxima pista;
                    }
                }
            }
            Se (!coloquei) {
                Manda para outro aeroporto;
            }
        }
    }
    >>> >>> >>> AVIÃO NORMAL {
        coloquei = 0;
        Se for de Decolagem {
            Olha em todas pistas - Ordena elas por quantidade de aviões;
            Deixa a P3 em primeiro lugar;
            Começa pela P3;
            While(Não testar todas as pistas && !coloquei) { 
                Se tiver vazia {
                    Coloca em primeiro lugar;
                    Quantidade da Pista++;
                    Tempo de interdição++
                    coloquei = 1;
                }
                Se não tiver {
                    N = Simulação de colocar na fila;
                    Se der certo {
                        Coloca em N;
                        Quantidade da Pista++;
                        Tempo de interdição++
                        coloquei = 1;
                    }
                    Vai para a proxima pista;
                }
            }
            Se (!coloquei) {
                Manda para outro aeroporto;
            }
        }
        Se for Pouso {
            Olha em todas pistas - Ordena elas por quantidade de aviões;
            Deixa a P3 por último;
            Começa pela com maior quantidade; 
            While(Não testar todas as pistas && !coloquei) { 
                Se tiver vazia {
                    Coloca em primeiro lugar;
                    Quantidade da Pista++;
                    Tempo de interdição++
                    coloquei = 1;
                }
                Se não tiver {
                    N = Simulação de colocar na fila;
                    Se der certo {
                        Coloca em N;
                        Quantidade da Pista++;
                        Tempo de interdição++
                        coloquei = 1;
                    }
                    Vai para a proxima pista;
                }
            }
            Se (!coloquei) {
                Manda para outro aeroporto;
            }
        }
    }
}



SIMULAÇÃO:  ( Devolva 0 se não der, Devolva POS(Posição que deu) se der)
    >> Recebe a pista;
    >> Recebe o avião - A;
    >> Recebe o instante de tempo - T;

    Se for especial {
        Começa no fim da fila da pista - POS (Quantidade de aviões);
        While(Não chegar no começo && nao_deu) {
            Testa com POS; *** 
            Se der certo {
                Proxima POS;
            }
            Se não {
                return 0;
            }
        }
        return 1;
    }

    Se for Normal {
        Começa na última posição da fila - POS (Quantidade de Aviões na fila);
        N = POS + 1;
        // Buscar uma posição aceitável;
        achei = 0;
        While (!achei && N != 0) {
            if(A.cob - (N - 1)*3 - (3 - T % 3) >= 0) {
                achei = 1;
            }
            else {
                N--;
            }
        }
        // Ao sair do loop, N marca a posição aceitável;
        Testa com N;
        if(N é válido) {
            return 1;
        }
        else {
            return 0;
        }
    }


    TESTANDO COM POS ( Devolve 1 se der certo, Devolve 0 se der errado)
        >>> Recebe posição - POS;
        >>> Recebe a pista;

        Me da o avião que está na posição POS - A;
        Se A.type == 1 {  // Avião Especial;
            return 0;
        }
        Se (A.com - t) - (3*(num_posicao_fila) - t%3) >= 3) {
            return 1;
        }
        Se não {
            return 0;
        }

    BUSCA POSIÇÃO ACEITAVEL (Devolve N - Posição aceitável)
        Recebe a fila;
        Recebe o avião - A;
        Recebe a quantidade de aviões na fila - N;
        Recebe o instante de tempo;

        if(A.comb - (N - 1)*3 - (3 - t % 3) > 0) 
            return N;
        Se não {
            N--;
        }



int media_comb_pouso_esperando, media_comb_pouso_pousados, media_tempo_espera_pouso, media_espera_decolagem, quantidade_emergencias;

mcpe - Média de combustível restante daqueles que estão na fila;
mcpp - Média de combustível dos aviões pousados no instante em que pousaram;

mtep - Ao pousar um avião, verifica o DeltaT de tempo passado e soma;
med - Ao decolar um avião, verifica o DeltaT de tempo passado e soma;


// >>> Insere um avião no fim da fila da Pista;
/* void Pista::insere_no_fim(Avioes A) {
    Fila * f;
    if(fila == nullptr) {
        fila = (Fila *) malloc(sizeof(Fila));
        fila->aviao = A;
        fila->ant = nullptr;
    }
    else { 
        for(f = fila; f->prox != nullptr; f = f->prox);
        f->prox = (Fila *) malloc(sizeof(Fila));
        f->prox->aviao = A;
        f->prox->ant = f;
    }
    quantidade++;
} 

// >>> Insere um avião no começo da fila da Pista;
void Pista::insere_no_comeco(Avioes A) {
    Fila * novo_elemento = (Fila *) malloc(sizeof(Fila));
    novo_elemento->aviao = A;
    novo_elemento->ant = nullptr;
    novo_elemento->prox = fila;
    fila = novo_elemento;
    quantidade++;
} */